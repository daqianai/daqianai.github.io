import{_ as t,c as s,o as i,ag as a}from"./chunks/framework.BDwTZuFy.js";const c=JSON.parse('{"title":"Latency optimization","description":"","frontmatter":{},"headers":[],"relativePath":"docs/openai/guides/latency-optimization.md","filePath":"docs/openai/guides/latency-optimization.md","lastUpdated":1748071461000}'),n={name:"docs/openai/guides/latency-optimization.md"};function o(r,e,l,p,h,u){return i(),s("div",null,e[0]||(e[0]=[a(`<h1 id="latency-optimization" tabindex="-1">Latency optimization <a class="header-anchor" href="#latency-optimization" aria-label="Permalink to &quot;Latency optimization&quot;">​</a></h1><p>Improve latency across a wide variety of LLM-related use cases.</p><p>This guide covers the core set of principles you can apply to improve latency across a wide variety of LLM-related use cases. These techniques come from working with a wide range of customers and developers on production applications, so they should apply regardless of what you&#39;re building – from a granular workflow to an end-to-end chatbot.</p><p>While there&#39;s many individual techniques, we&#39;ll be grouping them into <strong>seven principles</strong> meant to represent a high-level taxonomy of approaches for improving latency.</p><p>At the end, we&#39;ll walk through an <a href="#example">example</a> to see how they can be applied.</p><h3 id="seven-principles" tabindex="-1">Seven principles <a class="header-anchor" href="#seven-principles" aria-label="Permalink to &quot;Seven principles&quot;">​</a></h3><ol><li><a href="#process-tokens-faster">Process tokens faster.</a></li><li><a href="#generate-fewer-tokens">Generate fewer tokens.</a></li><li><a href="#use-fewer-input-tokens">Use fewer input tokens.</a></li><li><a href="#make-fewer-requests">Make fewer requests.</a></li><li><a href="#parallelize">Parallelize.</a></li><li><a href="#make-your-users-wait-less">Make your users wait less.</a></li><li><a href="#don-t-default-to-an-llm">Don&#39;t default to an LLM.</a></li></ol><h2 id="process-tokens-faster" tabindex="-1">Process tokens faster <a class="header-anchor" href="#process-tokens-faster" aria-label="Permalink to &quot;Process tokens faster&quot;">​</a></h2><p><strong>Inference speed</strong> is probably the first thing that comes to mind when addressing latency (but as you&#39;ll see soon, it&#39;s far from the only one). This refers to the actual <strong>rate at which the LLM processes tokens</strong>, and is often measured in TPM (tokens per minute) or TPS (tokens per second).</p><p>The main factor that influences inference speed is <strong>model size</strong> – smaller models usually run faster (and cheaper), and when used correctly can even outperform larger models. To maintain high quality performance with smaller models you can explore:</p><ul><li>using a longer, <a href="/docs/openai/guides/prompt-engineering#tactic-specify-the-steps-required-to-complete-a-task">more detailed prompt</a>,</li><li>adding (more) <a href="/docs/openai/guides/prompt-engineering#tactic-provide-examples">few-shot examples</a>, or</li><li><a href="/docs/openai/guides/fine-tuning">fine-tuning</a> / distillation.</li></ul><p>You can also employ inference optimizations like our <a href="/docs/openai/guides/predicted-outputs"><strong>Predicted outputs</strong></a> feature. Predicted outputs let you significantly reduce latency of a generation when you know most of the output ahead of time, such as code editing tasks. By giving the model a prediction, the LLM can focus more on the actual changes, and less on the content that will remain the same.</p><p>Deep dive</p><p>Compute capacity &amp; additional inference optimizations</p><h2 id="generate-fewer-tokens" tabindex="-1">Generate fewer tokens <a class="header-anchor" href="#generate-fewer-tokens" aria-label="Permalink to &quot;Generate fewer tokens&quot;">​</a></h2><p>Generating tokens is almost always the highest latency step when using an LLM: as a general heuristic, <strong>cutting 50% of your output tokens may cut ~50% your latency</strong>. The way you reduce your output size will depend on output type:</p><p>If you&#39;re generating <strong>natural language</strong>, simply <strong>asking the model to be more concise</strong> (&quot;under 20 words&quot; or &quot;be very brief&quot;) may help. You can also use few shot examples and/or fine-tuning to teach the model shorter responses.</p><p>If you&#39;re generating <strong>structured output</strong>, try to <strong>minimize your output syntax</strong> where possible: shorten function names, omit named arguments, coalesce parameters, etc.</p><p>Finally, while not common, you can also use <code>max_tokens</code> or <code>stop_tokens</code> to end your generation early.</p><p>Always remember: an output token cut is a (milli)second earned!</p><h2 id="use-fewer-input-tokens" tabindex="-1">Use fewer input tokens <a class="header-anchor" href="#use-fewer-input-tokens" aria-label="Permalink to &quot;Use fewer input tokens&quot;">​</a></h2><p>While reducing the number of input tokens does result in lower latency, this is not usually a significant factor – <strong>cutting 50% of your prompt may only result in a 1-5% latency improvement</strong>. Unless you&#39;re working with truly massive context sizes (documents, images), you may want to spend your efforts elsewhere.</p><p>That being said, if you <em>are</em> working with massive contexts (or you&#39;re set on squeezing every last bit of performance <em>and</em> you&#39;ve exhausted all other options) you can use the following techniques to reduce your input tokens:</p><ul><li><strong>Fine-tuning the model</strong>, to replace the need for lengthy instructions / examples.</li><li><strong>Filtering context input</strong>, like pruning RAG results, cleaning HTML, etc.</li><li><strong>Maximize shared prompt prefix</strong>, by putting dynamic portions (e.g. RAG results, history, etc) later in the prompt. This makes your request more <a href="https://medium.com/@joaolages/kv-caching-explained-276520203249" target="_blank" rel="noreferrer">KV cache</a>-friendly (which most LLM providers use) and means fewer input tokens are processed on each request.</li></ul><p>Check out our docs to learn more about how <a href="/docs/openai/guides/prompt-engineering#prompt-caching">prompt caching</a> works.</p><h2 id="make-fewer-requests" tabindex="-1">Make fewer requests <a class="header-anchor" href="#make-fewer-requests" aria-label="Permalink to &quot;Make fewer requests&quot;">​</a></h2><p>Each time you make a request you incur some round-trip latency – this can start to add up.</p><p>If you have sequential steps for the LLM to perform, instead of firing off one request per step consider <strong>putting them in a single prompt and getting them all in a single response</strong>. You&#39;ll avoid the additional round-trip latency, and potentially also reduce complexity of processing multiple responses.</p><p>An approach to doing this is by collecting your steps in an enumerated list in the combined prompt, and then requesting the model to return the results in named fields in a JSON. This way you can easily parse out and reference each result!</p><h2 id="parallelize" tabindex="-1">Parallelize <a class="header-anchor" href="#parallelize" aria-label="Permalink to &quot;Parallelize&quot;">​</a></h2><p>Parallelization can be very powerful when performing multiple steps with an LLM.</p><p>If the steps <strong>are <em>not</em> strictly sequential</strong>, you can <strong>split them out into parallel calls</strong>. Two shirts take just as long to dry as one.</p><p>If the steps <strong><em>are</em> strictly sequential</strong>, however, you might still be able to <strong>leverage speculative execution</strong>. This is particularly effective for classification steps where one outcome is more likely than the others (e.g. moderation).</p><ol><li>Start step 1 &amp; step 2 simultaneously (e.g. input moderation &amp; story generation)</li><li>Verify the result of step 1</li><li>If result was not the expected, cancel step 2 (and retry if necessary)</li></ol><p>If your guess for step 1 is right, then you essentially got to run it with zero added latency!</p><h2 id="make-your-users-wait-less" tabindex="-1">Make your users wait less <a class="header-anchor" href="#make-your-users-wait-less" aria-label="Permalink to &quot;Make your users wait less&quot;">​</a></h2><p>There&#39;s a huge difference between <strong>waiting</strong> and <strong>watching progress happen</strong> – make sure your users experience the latter. Here are a few techniques:</p><ul><li><strong>Streaming</strong>: The single most effective approach, as it cuts the <em>waiting</em> time to a second or less. (ChatGPT would feel pretty different if you saw nothing until each response was done.)</li><li><strong>Chunking</strong>: If your output needs further processing before being shown to the user (moderation, translation) consider <strong>processing it in chunks</strong> instead of all at once. Do this by streaming to your backend, then sending processed chunks to your frontend.</li><li><strong>Show your steps</strong>: If you&#39;re taking multiple steps or using tools, surface this to the user. The more real progress you can show, the better.</li><li><strong>Loading states</strong>: Spinners and progress bars go a long way.</li></ul><p>Note that while <strong>showing your steps &amp; having loading states</strong> have a mostly psychological effect, <strong>streaming &amp; chunking</strong> genuinely do reduce overall latency once you consider the app + user system: the user will finish reading a response sooner.</p><h2 id="don-t-default-to-an-llm" tabindex="-1">Don&#39;t default to an LLM <a class="header-anchor" href="#don-t-default-to-an-llm" aria-label="Permalink to &quot;Don&#39;t default to an LLM&quot;">​</a></h2><p>LLMs are extremely powerful and versatile, and are therefore sometimes used in cases where a <strong>faster classical method</strong> would be more appropriate. Identifying such cases may allow you to cut your latency significantly. Consider the following examples:</p><ul><li><strong>Hard-coding:</strong> If your <strong>output</strong> is highly constrained, you may not need an LLM to generate it. Action confirmations, refusal messages, and requests for standard input are all great candidates to be hard-coded. (You can even use the age-old method of coming up with a few variations for each.)</li><li><strong>Pre-computing:</strong> If your <strong>input</strong> is constrained (e.g. category selection) you can generate multiple responses in advance, and just make sure you never show the same one to a user twice.</li><li><strong>Leveraging UI:</strong> Summarized metrics, reports, or search results are sometimes better conveyed with classical, bespoke UI components rather than LLM-generated text.</li><li><strong>Traditional optimization techniques:</strong> An LLM application is still an application; binary search, caching, hash maps, and runtime complexity are all <em>still</em> useful in a world of LLMs.</li></ul><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h2><p>Let&#39;s now look at a sample application, identify potential latency optimizations, and propose some solutions!</p><p>We&#39;ll be analyzing the architecture and prompts of a hypothetical customer service bot inspired by real production applications. The <a href="#architecture-and-prompts">architecture and prompts</a> section sets the stage, and the <a href="#analysis-and-optimizations">analysis and optimizations</a> section will walk through the latency optimization process.</p><p>You&#39;ll notice this example doesn&#39;t cover every single principle, much like real-world use cases don&#39;t require applying every technique.</p><h3 id="architecture-and-prompts" tabindex="-1">Architecture and prompts <a class="header-anchor" href="#architecture-and-prompts" aria-label="Permalink to &quot;Architecture and prompts&quot;">​</a></h3><p>The following is the <strong>initial architecture</strong> for a hypothetical <strong>customer service bot</strong>. This is what we&#39;ll be making changes to.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-0.png" alt="Assistants object architecture diagram"></p><p>At a high level, the diagram flow describes the following process:</p><ol><li>A user sends a message as part of an ongoing conversation.</li><li>The last message is turned into a <strong>self-contained query</strong> (see examples in prompt).</li><li>We determine whether or not <strong>additional (retrieved) information is required</strong> to respond to that query.</li><li><strong>Retrieval</strong> is performed, producing search results.</li><li>The assistant <strong>reasons</strong> about the user&#39;s query and search results, and <strong>produces a response</strong>.</li><li>The response is sent back to the user.</li></ol><p>Below are the prompts used in each part of the diagram. While they are still only hypothetical and simplified, they are written with the same structure and wording that you would find in a production application.</p><p>Places where you see placeholders like &quot;<strong>[user input here]</strong>&quot; represent dynamic portions, that would be replaced by actual data at runtime.</p><p>Query contextualization prompt</p><p>Re-writes user query to be a self-contained search query.</p><p>SYSTEM</p><p>Given the previous conversation, re-write the last user query so it contains all necessary context. # Example History: [{user: &quot;What is your return policy?&quot;},{assistant: &quot;...&quot;}] User Query: &quot;How long does it cover?&quot; Response: &quot;How long does the return policy cover?&quot; # Conversation [last 3 messages of conversation] # User Query [last user query]</p><p>USER</p><p>[JSON-formatted input conversation here]</p><p>Retrieval check prompt</p><p>Determines whether a query requires performing retrieval to respond.</p><p>SYSTEM</p><p>Given a user query, determine whether it requires doing a realtime lookup to respond to. # Examples User Query: &quot;How can I return this item after 30 days?&quot; Response: &quot;true&quot; User Query: &quot;Thank you!&quot; Response: &quot;false&quot;</p><p>USER</p><p>[input user query here]</p><p>Assistant prompt</p><p>Fills the fields of a JSON to reason through a pre-defined set of steps to produce a final response given a user conversation and relevant retrieved information.</p><p>SYSTEM</p><p>You are a helpful customer service bot. Use the result JSON to reason about each user query - use the retrieved context. # Example User: &quot;My computer screen is cracked! I want it fixed now!!!&quot; Assistant Response: { &quot;message_is_conversation_continuation&quot;: &quot;True&quot;, &quot;number_of_messages_in_conversation_so_far&quot;: &quot;1&quot;, &quot;user_sentiment&quot;: &quot;Aggravated&quot;, &quot;query_type&quot;: &quot;Hardware Issue&quot;, &quot;response_tone&quot;: &quot;Validating and solution-oriented&quot;, &quot;response_requirements&quot;: &quot;Propose options for repair or replacement.&quot;, &quot;user_requesting_to_talk_to_human&quot;: &quot;False&quot;, &quot;enough_information_in_context&quot;: &quot;True&quot;, &quot;response&quot;: &quot;...&quot; }</p><p>USER</p><p># Relevant Information \` \` \` [retrieved context] \` \` \`</p><p>USER</p><p>[input user query here]</p><h3 id="analysis-and-optimizations" tabindex="-1">Analysis and optimizations <a class="header-anchor" href="#analysis-and-optimizations" aria-label="Permalink to &quot;Analysis and optimizations&quot;">​</a></h3><h4 id="part-1-looking-at-retrieval-prompts" tabindex="-1">Part 1: Looking at retrieval prompts <a class="header-anchor" href="#part-1-looking-at-retrieval-prompts" aria-label="Permalink to &quot;Part 1: Looking at retrieval prompts&quot;">​</a></h4><p>Looking at the architecture, the first thing that stands out is the <strong>consecutive GPT-4 calls</strong> - these hint at a potential inefficiency, and can often be replaced by a single call or parallel calls.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-2.png" alt="Assistants object architecture diagram"></p><p>In this case, since the check for retrieval requires the contextualized query, let&#39;s <strong>combine them into a single prompt</strong> to <a href="#make-fewer-requests">make fewer requests</a>.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-3.png" alt="Assistants object architecture diagram"></p><p>Combined query contextualization and retrieval check prompt</p><p><strong>What changed?</strong> Before, we had one prompt to re-write the query and one to determine whether this requires doing a retrieval lookup. Now, this combined prompt does both. Specifically, notice the updated instruction in the first line of the prompt, and the updated output JSON:</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  query</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[contextualized query]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  retrieval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[true/false - whether retrieval is required]&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>SYSTEM</p><p>Given the previous conversation, re-write the last user query so it contains all necessary context. Then, determine whether the full request requires doing a realtime lookup to respond to. Respond in the following form: { query:&quot;[contextualized query]&quot;, retrieval:&quot;[true/false - whether retrieval is required]&quot; } # Examples History: [{user: &quot;What is your return policy?&quot;},{assistant: &quot;...&quot;}] User Query: &quot;How long does it cover?&quot; Response: {query: &quot;How long does the return policy cover?&quot;, retrieval: &quot;true&quot;} History: [{user: &quot;How can I return this item after 30 days?&quot;},{assistant: &quot;...&quot;}] User Query: &quot;Thank you!&quot; Response: {query: &quot;Thank you!&quot;, retrieval: &quot;false&quot;} # Conversation [last 3 messages of conversation] # User Query [last user query]</p><p>USER</p><p>[JSON-formatted input conversation here]</p><p>Actually, adding context and determining whether to retrieve are very straightforward and well defined tasks, so we can likely use a <strong>smaller, fine-tuned model</strong> instead. Switching to GPT-3.5 will let us <a href="#process-tokens-faster">process tokens faster</a>.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-4.png" alt="Assistants object architecture diagram"></p><h4 id="part-2-analyzing-the-assistant-prompt" tabindex="-1">Part 2: Analyzing the assistant prompt <a class="header-anchor" href="#part-2-analyzing-the-assistant-prompt" aria-label="Permalink to &quot;Part 2: Analyzing the assistant prompt&quot;">​</a></h4><p>Let&#39;s now direct our attention to the Assistant prompt. There seem to be many distinct steps happening as it fills the JSON fields – this could indicate an opportunity to <a href="#parallelize">parallelize</a>.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-5.png" alt="Assistants object architecture diagram"></p><p>However, let&#39;s pretend we have run some tests and discovered that splitting the reasoning steps in the JSON produces worse responses, so we need to explore different solutions.</p><p><strong>Could we use a fine-tuned GPT-3.5 instead of GPT-4?</strong> Maybe – but in general, open-ended responses from assistants are best left to GPT-4 so it can better handle a greater range of cases. That being said, looking at the reasoning steps themselves, they may not all require GPT-4 level reasoning to produce. The well defined, limited scope nature makes them and <strong>good potential candidates for fine-tuning</strong>.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;message_is_conversation_continuation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;True&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;number_of_messages_in_conversation_so_far&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;user_sentiment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Aggravated&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;query_type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hardware Issue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;response_tone&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Validating and solution-oriented&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;response_requirements&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Propose options for repair or replacement.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;user_requesting_to_talk_to_human&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;False&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;enough_information_in_context&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;True&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;response&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;...&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // X -- benefits from GPT-4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This opens up the possibility of a trade-off. Do we keep this as a <strong>single request entirely generated by GPT-4</strong>, or <strong>split it into two sequential requests</strong> and use GPT-3.5 for all but the final response? We have a case of conflicting principles: the first option lets us <a href="#make-fewer-requests">make fewer requests</a>, but the second may let us <a href="#1-process-tokens-faster">process tokens faster</a>.</p><p>As with many optimization tradeoffs, the answer will depend on the details. For example:</p><ul><li>The proportion of tokens in the <code>response</code> vs the other fields.</li><li>The average latency decrease from processing most fields faster.</li><li>The average latency <em>increase</em> from doing two requests instead of one.</li></ul><p>The conclusion will vary by case, and the best way to make the determiation is by testing this with production examples. In this case let&#39;s pretend the tests indicated it&#39;s favorable to split the prompt in two to <a href="#process-tokens-faster">process tokens faster</a>.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-6.png" alt="Assistants object architecture diagram"></p><p><strong>Note:</strong> We&#39;ll be grouping <code>response</code> and <code>enough_information_in_context</code> together in the second prompt to avoid passing the retrieved context to both new prompts.</p><p>Assistants prompt - reasoning</p><p>This prompt will be passed to GPT-3.5 and can be fine-tuned on curated examples.</p><p><strong>What changed?</strong> The &quot;enough_information_in_context&quot; and &quot;response&quot; fields were removed, and the retrieval results are no longer loaded into this prompt.</p><p>SYSTEM</p><p>You are a helpful customer service bot. Based on the previous conversation, respond in a JSON to determine the required fields. # Example User: &quot;My freaking computer screen is cracked!&quot; Assistant Response: { &quot;message_is_conversation_continuation&quot;: &quot;True&quot;, &quot;number_of_messages_in_conversation_so_far&quot;: &quot;1&quot;, &quot;user_sentiment&quot;: &quot;Aggravated&quot;, &quot;query_type&quot;: &quot;Hardware Issue&quot;, &quot;response_tone&quot;: &quot;Validating and solution-oriented&quot;, &quot;response_requirements&quot;: &quot;Propose options for repair or replacement.&quot;, &quot;user_requesting_to_talk_to_human&quot;: &quot;False&quot;, }</p><p>Assistants prompt - response</p><p>This prompt will be processed by GPT-4 and will receive the reasoning steps determined in the prior prompt, as well as the results from retrieval.</p><p><strong>What changed?</strong> All steps were removed except for &quot;enough_information_in_context&quot; and &quot;response&quot;. Additionally, the JSON we were previously filling in as output will be passed in to this prompt.</p><p>SYSTEM</p><p>You are a helpful customer service bot. Use the retrieved context, as well as these pre-classified fields, to respond to the user&#39;s query. # Reasoning Fields \` \` \` [reasoning json determined in previous GPT-3.5 call] \` \` \` # Example User: &quot;My freaking computer screen is cracked!&quot; Assistant Response: { &quot;enough_information_in_context&quot;: &quot;True&quot;, &quot;response&quot;: &quot;...&quot; }</p><p>USER</p><p># Relevant Information \` \` \` [retrieved context] \` \` \`</p><p>In fact, now that the reasoning prompt does not depend on the retrieved context we can <a href="#parallelize">parallelize</a> and fire it off at the same time as the retrieval prompts.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-6b.png" alt="Assistants object architecture diagram"></p><h4 id="part-3-optimizing-the-structured-output" tabindex="-1">Part 3: Optimizing the structured output <a class="header-anchor" href="#part-3-optimizing-the-structured-output" aria-label="Permalink to &quot;Part 3: Optimizing the structured output&quot;">​</a></h4><p>Let&#39;s take another look at the reasoning prompt.</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-7b.png" alt="Assistants object architecture diagram"></p><p>Taking a closer look at the reasoning JSON you may notice the field names themselves are quite long.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;message_is_conversation_continuation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;True&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;number_of_messages_in_conversation_so_far&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;user_sentiment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Aggravated&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;query_type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hardware Issue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;response_tone&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Validating and solution-oriented&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;response_requirements&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Propose options for repair or replacement.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;user_requesting_to_talk_to_human&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;False&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;-</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>By making them shorter and moving explanations to the comments we can <a href="#generate-fewer-tokens">generate fewer tokens</a>.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;cont&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;True&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// whether last message is a continuation</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;n_msg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// number of messages in the continued conversation</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;tone_in&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Aggravated&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sentiment of user query</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hardware Issue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// type of the user query</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;tone_out&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Validating and solution-oriented&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// desired tone for response</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;reqs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Propose options for repair or replacement.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// response requirements</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;human&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;False&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// whether user is expressing want to talk to human</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-8b.png" alt="Assistants object architecture diagram"></p><p>This small change removed 19 output tokens. While with GPT-3.5 this may only result in a few millisecond improvement, with GPT-4 this could shave off up to a second.</p><p><img src="https://cdn.openai.com/API/docs/images/token-counts-latency-customer-service-large.png" alt="Assistants object architecture diagram"></p><p>You might imagine, however, how this can have quite a significant impact for larger model outputs.</p><p>We could go further and use single chatacters for the JSON fields, or put everything in an array, but this may start to hurt our response quality. The best way to know, once again, is through testing.</p><h4 id="example-wrap-up" tabindex="-1">Example wrap-up <a class="header-anchor" href="#example-wrap-up" aria-label="Permalink to &quot;Example wrap-up&quot;">​</a></h4><p>Let&#39;s review the optimizations we implemented for the customer service bot example:</p><p><img src="https://cdn.openai.com/API/docs/images/diagram-latency-customer-service-11b.png" alt="Assistants object architecture diagram"></p><ol><li><strong>Combined</strong> query contextualization and retrieval check steps to <a href="#make-fewer-requests">make fewer requests</a>.</li><li>For the new prompt, <strong>switched to a smaller, fine-tuned GPT-3.5</strong> to <a href="./process-tokens-faster">process tokens faster</a>.</li><li>Split the assistant prompt in two, <strong>switching to a smaller, fine-tuned GPT-3.5</strong> for the reasoning, again to <a href="#process-tokens-faster">process tokens faster</a>.</li><li><a href="#parallelize">Parallelized</a> the retrieval checks and the reasoning steps.</li><li><strong>Shortened reasoning field names</strong> and moved comments into the prompt, to <a href="#generate-fewer-tokens">generate fewer tokens</a>.</li></ol>`,130)]))}const g=t(n,[["render",o]]);export{c as __pageData,g as default};
